Here's an example lab scenario to illustrate a Broken Object Level Authorization (BOLA) vulnerability. This example involves a simple web application with a RESTful API that manages user profiles.

### Lab Setup

#### 1. Application Description

- **Functionality**: A simple web application where users can view and update their profiles.
- **Tech Stack**: Node.js and Express for the backend, MongoDB for the database.

#### 2. Database Schema

- **Users Collection**:
  ```json
  {
    "_id": "ObjectId",
    "username": "string",
    "password": "string",
    "email": "string",
    "profile": {
      "firstName": "string",
      "lastName": "string",
      "address": "string"
    }
  }
  ```

### Vulnerable Code Example

#### 1. Server Setup (server.js)
```javascript
const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const User = require('./models/User');

const app = express();
app.use(bodyParser.json());

mongoose.connect('mongodb://localhost:27017/bola_lab', { useNewUrlParser: true, useUnifiedTopology: true });

// Endpoint to get user profile by ID
app.get('/api/user/:id', async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) {
      return res.status(404).send('User not found');
    }
    res.send(user.profile);
  } catch (err) {
    res.status(500).send(err);
  }
});

// Endpoint to update user profile by ID
app.put('/api/user/:id', async (req, res) => {
  try {
    const user = await User.findByIdAndUpdate(req.params.id, { profile: req.body }, { new: true });
    if (!user) {
      return res.status(404).send('User not found');
    }
    res.send(user.profile);
  } catch (err) {
    res.status(500).send(err);
  }
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

#### 2. User Model (models/User.js)
```javascript
const mongoose = require('mongoose');

const UserSchema = new mongoose.Schema({
  username: { type: String, required: true },
  password: { type: String, required: true },
  email: { type: String, required: true },
  profile: {
    firstName: { type: String, required: true },
    lastName: { type: String, required: true },
    address: { type: String, required: true }
  }
});

module.exports = mongoose.model('User', UserSchema);
```

### Vulnerability Demonstration

1. **Create Users**: Create two users, Alice and Bob, with their respective profiles.

2. **Alice's Request**: Alice logs in and wants to view or update her profile. She sends a GET request to:
   ```
   GET /api/user/{Alice's ID}
   ```

3. **BOLA Exploit**: Alice realizes that she can change the ID in the URL to Bob's ID and get Bob's profile details:
   ```
   GET /api/user/{Bob's ID}
   ```

4. **Result**: Alice can now access Bob's profile information, which she shouldn't be able to. Similarly, Alice can update Bob's profile by sending a PUT request to:
   ```
   PUT /api/user/{Bob's ID}
   ```

### How to Fix It

1. **User Authentication and Authorization Middleware**: Implement middleware to verify the authenticated user's identity and ensure they can only access their own data.

2. **Secure Endpoints**:
   - **server.js**:
     ```javascript
     const jwt = require('jsonwebtoken');
     const secretKey = 'your_secret_key'; // In real applications, keep this secret and secure.

     // Authentication Middleware
     function authenticateToken(req, res, next) {
       const token = req.headers['authorization'];
       if (!token) return res.sendStatus(401);

       jwt.verify(token, secretKey, (err, user) => {
         if (err) return res.sendStatus(403);
         req.user = user;
         next();
       });
     }

     // Secure the user endpoints
     app.get('/api/user/:id', authenticateToken, async (req, res) => {
       if (req.user.id !== req.params.id) return res.sendStatus(403);

       try {
         const user = await User.findById(req.params.id);
         if (!user) {
           return res.status(404).send('User not found');
         }
         res.send(user.profile);
       } catch (err) {
         res.status(500).send(err);
       }
     });

     app.put('/api/user/:id', authenticateToken, async (req, res) => {
       if (req.user.id !== req.params.id) return res.sendStatus(403);

       try {
         const user = await User.findByIdAndUpdate(req.params.id, { profile: req.body }, { new: true });
         if (!user) {
           return res.status(404).send('User not found');
         }
         res.send(user.profile);
       } catch (err) {
         res.status(500).send(err);
       }
     });
     ```

### Conclusion

This example lab demonstrates a BOLA vulnerability where users can access and modify each other's profiles. By implementing proper authentication and authorization checks, you can prevent such vulnerabilities and ensure that users can only access their own data.
